generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============ Users & Authentication ============

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  apiKeys ApiKey[]
  bots    Bot[]

  @@index([email])
}

model ApiKey {
  id        String   @id @default(cuid())
  userId    String
  name      String
  keyHash   String   @unique
  scopes    String[] // ['read', 'trade', 'manage']
  lastUsed  DateTime?
  expiresAt DateTime?
  createdAt DateTime @default(now())
  revokedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([keyHash])
  @@index([userId])
}

// ============ Bots & Configuration ============

model Bot {
  id          String    @id @default(cuid())
  userId      String
  name        String
  symbol      String
  config      Json      // BotConfig JSON
  status      BotStatus @default(STOPPED)
  paperTrading Boolean  @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  runs           BotRun[]
  trades         Trade[]
  signals        Signal[]
  critiqueReports CritiqueReport[]
  paramChanges   ParamChange[]

  @@index([userId])
  @@index([status])
}

enum BotStatus {
  RUNNING
  STOPPED
  PAUSED
  ERROR
}

model BotRun {
  id        String    @id @default(cuid())
  botId     String
  startedAt DateTime  @default(now())
  stoppedAt DateTime?
  reason    String?
  metrics   Json?     // Performance metrics at end of run

  bot    Bot     @relation(fields: [botId], references: [id], onDelete: Cascade)
  trades Trade[]

  @@index([botId])
  @@index([startedAt])
}

// ============ Trading ============

model Trade {
  id           String      @id @default(cuid())
  botId        String
  botRunId     String?
  symbol       String
  side         TradeSide
  entryPrice   Float
  exitPrice    Float?
  quantity     Float
  entryTime    DateTime
  exitTime     DateTime?
  pnl          Float?
  pnlPercent   Float?
  fees         Float       @default(0)
  status       TradeStatus @default(OPEN)
  signalId     String?
  orderId      String?
  exitOrderId  String?
  stopLoss     Float?
  takeProfit   Float?
  notes        String?
  metadata     Json?

  bot    Bot     @relation(fields: [botId], references: [id], onDelete: Cascade)
  botRun BotRun? @relation(fields: [botRunId], references: [id])
  signal Signal? @relation(fields: [signalId], references: [id])

  @@index([botId])
  @@index([status])
  @@index([entryTime])
  @@index([symbol])
}

enum TradeSide {
  BUY
  SELL
}

enum TradeStatus {
  OPEN
  CLOSED
}

model Signal {
  id         String       @id @default(cuid())
  botId      String
  symbol     String
  timeframe  String
  action     SignalAction
  confidence Float
  price      Float
  indicators Json         // Record<string, number>
  reasons    String[]
  createdAt  DateTime     @default(now())

  bot    Bot     @relation(fields: [botId], references: [id], onDelete: Cascade)
  trades Trade[]

  @@index([botId])
  @@index([createdAt])
}

enum SignalAction {
  LONG
  SHORT
  CLOSE_LONG
  CLOSE_SHORT
  HOLD
}

// ============ Self-Critique System ============

model CritiqueReport {
  id              String   @id @default(cuid())
  botId           String
  tradeIds        String[]
  metrics         Json     // CritiqueMetrics
  whatWorked      String[]
  whatDidntWork   String[]
  failurePatterns String[]
  recommendations Json     // ParameterChange[]
  appliedChanges  Json     // ParameterChange[]
  createdAt       DateTime @default(now())

  bot          Bot           @relation(fields: [botId], references: [id], onDelete: Cascade)
  paramChanges ParamChange[]

  @@index([botId])
  @@index([createdAt])
}

model ParamChange {
  id              String   @id @default(cuid())
  botId           String
  critiqueReportId String?
  parameter       String
  previousValue   Json
  newValue        Json
  reason          String
  applied         Boolean  @default(false)
  rolledBack      Boolean  @default(false)
  createdAt       DateTime @default(now())

  bot            Bot             @relation(fields: [botId], references: [id], onDelete: Cascade)
  critiqueReport CritiqueReport? @relation(fields: [critiqueReportId], references: [id])

  @@index([botId])
  @@index([createdAt])
}

// ============ Decision Records (V3) ============

model Decision {
  id              String   @id @default(cuid())
  userId          String?
  botId           String?
  symbol          String
  timeframe       String
  timestamp       DateTime // Candle timestamp this decision relates to
  action          DecisionAction
  confidenceScore Int      // 0-100 computed score
  blockedReason   String?  // If blocked, why
  executed        Boolean  @default(false)
  tradeId         String?  // Link to Trade if executed
  critiqueId      String?  // Link to CritiqueReport if reviewed
  createdAt       DateTime @default(now())

  breakdown DecisionBreakdown?
  evidence  DecisionEvidence[]
  markers   ChartMarker[]

  @@index([botId])
  @@index([symbol, timeframe])
  @@index([timestamp])
  @@index([createdAt])
  @@index([action])
}

enum DecisionAction {
  LONG
  SHORT
  CLOSE_LONG
  CLOSE_SHORT
  HOLD
  NO_TRADE
}

model DecisionBreakdown {
  id             String @id @default(cuid())
  decisionId     String @unique
  dataQuality    Int    // 0-20
  signalAgreement Int   // 0-30
  riskFit        Int    // 0-25
  regimeMatch    Int    // 0-15
  newsBonus      Int    // 0-10

  decision Decision @relation(fields: [decisionId], references: [id], onDelete: Cascade)
}

model DecisionEvidence {
  id         String         @id @default(cuid())
  decisionId String
  type       EvidenceType
  label      String         // e.g. "EMA20 > EMA50", "RSI < 30"
  value      String         // The actual value
  status     EvidenceStatus
  weight     Int            // Contribution to score
  sourceUrl  String?        // For Grok sources

  decision Decision @relation(fields: [decisionId], references: [id], onDelete: Cascade)

  @@index([decisionId])
}

enum EvidenceType {
  INDICATOR
  GROK
  RISK
  DATA
  REGIME
}

enum EvidenceStatus {
  PASS
  FAIL
  UNKNOWN
}

// ============ Chart Markers (V3) ============

model ChartMarker {
  id         String      @id @default(cuid())
  decisionId String?
  botId      String?
  symbol     String
  timeframe  String
  timestamp  DateTime
  kind       MarkerKind
  price      Float
  side       String?     // LONG, SHORT
  label      String?
  meta       Json?
  createdAt  DateTime    @default(now())

  decision Decision? @relation(fields: [decisionId], references: [id], onDelete: SetNull)

  @@index([symbol, timeframe, timestamp])
  @@index([decisionId])
}

enum MarkerKind {
  ENTRY
  EXIT
  STOP_LOSS
  TAKE_PROFIT
  NO_TRADE
  NOTE
}

// ============ Market Data Snapshots (Optional) ============

model MarketSnapshot {
  id        String   @id @default(cuid())
  symbol    String
  timeframe String
  timestamp DateTime
  open      Float
  high      Float
  low       Float
  close     Float
  volume    Float

  @@unique([symbol, timeframe, timestamp])
  @@index([symbol, timeframe])
  @@index([timestamp])
}

// ============ AI Learning System ============

// Stores AI rules and templates that Grok must follow
model AIRule {
  id          String       @id @default(cuid())
  botId       String?      // null = global rule
  category    AIRuleCategory
  name        String
  description String
  template    String       // The actual prompt template
  isActive    Boolean      @default(true)
  isSystem    Boolean      @default(false) // System rules can't be deleted
  priority    Int          @default(0)     // Higher = more important
  constraints Json?        // Min/max limits for parameters
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([botId])
  @@index([category])
  @@index([isActive])
}

enum AIRuleCategory {
  MACRO_ANALYSIS      // Rules for macro/news analysis
  TECHNICAL_ANALYSIS  // Rules for technical indicators
  RISK_MANAGEMENT     // Rules for position sizing, SL/TP
  ENTRY_CONDITIONS    // Rules for when to enter
  EXIT_CONDITIONS     // Rules for when to exit
  SELF_CRITIQUE       // Rules for self-analysis
  USER_CUSTOM         // User-defined custom rules
}

// Stores insights learned from trading history
model AIInsight {
  id          String      @id @default(cuid())
  botId       String
  type        InsightType
  title       String
  description String
  confidence  Float       // 0-100, how confident is this insight
  dataPoints  Int         // Number of trades/events this is based on
  evidence    Json        // Supporting data
  isValid     Boolean     @default(true) // Can be invalidated by new data
  appliedAt   DateTime?   // When user applied this insight
  createdAt   DateTime    @default(now())
  expiresAt   DateTime?   // Some insights may expire

  @@index([botId])
  @@index([type])
  @@index([createdAt])
}

enum InsightType {
  PATTERN_DETECTED     // Recurring pattern in trades
  PARAMETER_SUGGESTION // Suggestion to change a parameter
  RISK_WARNING         // Warning about risk exposure
  PERFORMANCE_TREND    // Trend in performance metrics
  MARKET_CONDITION     // Observation about market conditions
  STRATEGY_IMPROVEMENT // Suggestion to improve strategy
}

// Stores AI suggestions for the user
model AISuggestion {
  id           String           @id @default(cuid())
  botId        String
  type         SuggestionType
  title        String
  description  String
  reasoning    String           // Detailed explanation with sources
  impact       String           // Expected impact if applied
  confidence   Float            // 0-100
  priority     SuggestionPriority
  status       SuggestionStatus @default(PENDING)
  parameters   Json?            // Suggested parameter changes
  sources      Json             // Real data sources (X posts, news, indicators)
  userFeedback String?          // User's feedback if rejected
  createdAt    DateTime         @default(now())
  reviewedAt   DateTime?
  appliedAt    DateTime?

  @@index([botId])
  @@index([status])
  @@index([createdAt])
}

enum SuggestionType {
  PARAMETER_CHANGE
  RULE_ADDITION
  RULE_MODIFICATION
  RISK_ADJUSTMENT
  STRATEGY_CHANGE
  MARKET_ALERT
}

enum SuggestionPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum SuggestionStatus {
  PENDING
  VIEWED
  APPLIED
  REJECTED
  EXPIRED
}

// Stores real-time data from external sources (X, news)
model ExternalData {
  id          String           @id @default(cuid())
  source      ExternalSource
  sourceId    String           // Original ID from source
  content     String
  author      String?
  url         String?
  sentiment   String?          // bullish, bearish, neutral
  relevance   Float?           // 0-100, how relevant to trading
  symbols     String[]         // Related symbols
  metadata    Json?
  fetchedAt   DateTime         @default(now())
  expiresAt   DateTime         // When this data becomes stale

  @@unique([source, sourceId])
  @@index([source])
  @@index([fetchedAt])
  @@index([symbols])
}

enum ExternalSource {
  X_TWITTER
  NEWS_API
  COINGECKO
  HYPERLIQUID
  USER_INPUT
}

// Stores Grok analysis results for audit trail
model GrokAnalysis {
  id              String        @id @default(cuid())
  botId           String?
  analysisType    GrokAnalysisType
  query           String        // What was asked
  prompt          String        // Full prompt sent to Grok
  response        String        // Raw response
  parsedResult    Json          // Structured result
  sources         Json          // Sources used
  confidence      Float         // 0-100
  processingTimeMs Int
  tokenCount      Int?
  createdAt       DateTime      @default(now())

  @@index([botId])
  @@index([analysisType])
  @@index([createdAt])
}

enum GrokAnalysisType {
  MACRO_SENTIMENT
  RUMOR_CHECK
  TRADE_ANALYSIS
  SELF_CRITIQUE
  PARAMETER_OPTIMIZATION
  MARKET_REGIME
}

// Stores user-defined limits and guardrails
model UserGuardrail {
  id          String         @id @default(cuid())
  botId       String
  parameter   String         // e.g. "leverage", "positionSizePct"
  minValue    Float?
  maxValue    Float?
  description String?
  isActive    Boolean        @default(true)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@unique([botId, parameter])
  @@index([botId])
}

// Stores the learning history for continuous improvement
model LearningEntry {
  id          String       @id @default(cuid())
  botId       String
  entryType   LearningType
  context     Json         // Market conditions, indicators at time
  action      String       // What action was taken
  outcome     String       // What happened
  lesson      String       // What was learned
  confidence  Float        // How confident in this lesson
  tradeIds    String[]     // Related trades
  createdAt   DateTime     @default(now())

  @@index([botId])
  @@index([entryType])
  @@index([createdAt])
}

enum LearningType {
  SUCCESSFUL_TRADE
  FAILED_TRADE
  MISSED_OPPORTUNITY
  AVOIDED_LOSS
  PARAMETER_CHANGE_RESULT
  MARKET_REGIME_CHANGE
}

// ============ AI Thinking Logs (Real-time streaming) ============

// Stores complete AI thinking sessions for replay and audit
model AIThinkingSession {
  id              String   @id @default(cuid())
  botId           String?
  userId          String?
  symbol          String
  timeframe       String
  sessionType     AISessionType
  status          AISessionStatus @default(IN_PROGRESS)
  startedAt       DateTime @default(now())
  completedAt     DateTime?
  totalDurationMs Int?
  finalAction     String?  // LONG, SHORT, HOLD, etc.
  finalConfidence Float?
  inputData       Json     // Price, indicators, etc. at start
  outputData      Json?    // Final analysis result
  
  steps AIThinkingStep[]
  
  @@index([botId])
  @@index([userId])
  @@index([symbol, timeframe])
  @@index([startedAt])
  @@index([status])
}

enum AISessionType {
  MARKET_ANALYSIS
  TRADE_DECISION
  SELF_CRITIQUE
  PARAMETER_OPTIMIZATION
  SENTIMENT_CHECK
}

enum AISessionStatus {
  IN_PROGRESS
  COMPLETED
  FAILED
  CANCELLED
}

// Individual thinking steps within a session
model AIThinkingStep {
  id          String   @id @default(cuid())
  sessionId   String
  stepNumber  Int
  stepType    AIStepType
  title       String   // e.g. "Analyzing Price Action", "Checking RSI"
  content     String   // The actual thinking/reasoning
  data        Json?    // Any associated data (indicator values, etc.)
  status      AIStepStatus @default(PENDING)
  durationMs  Int?
  createdAt   DateTime @default(now())
  
  session AIThinkingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  
  @@index([sessionId])
  @@index([stepNumber])
}

enum AIStepType {
  DATA_COLLECTION     // Gathering price, volume, indicators
  INDICATOR_ANALYSIS  // Analyzing technical indicators
  SENTIMENT_ANALYSIS  // Analyzing X/Twitter sentiment
  NEWS_ANALYSIS       // Analyzing news
  CONFIRMATION_CHECK  // Checking confirmations
  RISK_ASSESSMENT     // Assessing risk
  DECISION_MAKING     // Making final decision
  REASONING           // General reasoning step
}

enum AIStepStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  SKIPPED
  FAILED
}

// ============ User Statistics & Portfolio ============

// Wallet-based user profile (DeFi - no email)
model WalletProfile {
  id              String   @id @default(cuid())
  walletAddress   String   @unique
  nickname        String?
  avatarUrl       String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  lastActiveAt    DateTime @default(now())
  
  // Settings
  settings        Json?    // User preferences
  
  // Relations
  portfolioStats  PortfolioStats?
  dailyStats      DailyStats[]
  tradeHistory    TradeHistory[]
  walletTrades    WalletTrade[]
  referrals       Referral[]      @relation("Referrer")
  referredBy      Referral?       @relation("Referred")
  userBots        UserBot[]
  libraryItems    LibraryItem[]
  
  @@index([walletAddress])
}

// Overall portfolio statistics
model PortfolioStats {
  id              String   @id @default(cuid())
  walletAddress   String   @unique
  
  // Equity tracking
  initialEquity   Float    @default(0)
  currentEquity   Float    @default(0)
  peakEquity      Float    @default(0)
  
  // PNL
  totalPnl        Float    @default(0)
  realizedPnl     Float    @default(0)
  unrealizedPnl   Float    @default(0)
  
  // Trade statistics
  totalTrades     Int      @default(0)
  winningTrades   Int      @default(0)
  losingTrades    Int      @default(0)
  winRate         Float    @default(0)
  
  // Performance metrics
  avgWin          Float    @default(0)
  avgLoss         Float    @default(0)
  largestWin      Float    @default(0)
  largestLoss     Float    @default(0)
  profitFactor    Float    @default(0)
  expectancy      Float    @default(0)
  sharpeRatio     Float    @default(0)
  
  // Drawdown
  maxDrawdown     Float    @default(0)
  maxDrawdownPct  Float    @default(0)
  currentDrawdown Float    @default(0)
  
  // Streaks
  currentStreak   Int      @default(0)  // Positive = wins, negative = losses
  longestWinStreak  Int    @default(0)
  longestLoseStreak Int    @default(0)
  
  // Time-based
  avgHoldTime     Int      @default(0)  // In seconds
  
  updatedAt       DateTime @updatedAt
  
  profile WalletProfile @relation(fields: [walletAddress], references: [walletAddress], onDelete: Cascade)
  
  @@index([walletAddress])
}

// Daily statistics snapshot
model DailyStats {
  id              String   @id @default(cuid())
  walletAddress   String
  date            DateTime @db.Date
  
  // Daily PNL
  pnl             Float    @default(0)
  pnlPercent      Float    @default(0)
  
  // Daily trades
  trades          Int      @default(0)
  wins            Int      @default(0)
  losses          Int      @default(0)
  winRate         Float    @default(0)
  
  // Volume
  volume          Float    @default(0)
  fees            Float    @default(0)
  
  // Equity at end of day
  equity          Float    @default(0)
  
  createdAt       DateTime @default(now())
  
  profile WalletProfile @relation(fields: [walletAddress], references: [walletAddress], onDelete: Cascade)
  
  @@unique([walletAddress, date])
  @@index([walletAddress])
  @@index([date])
}

// Trade history for user
model TradeHistory {
  id              String   @id @default(cuid())
  walletAddress   String
  
  // Trade details
  symbol          String
  side            String   // 'long' or 'short'
  entryPrice      Float
  exitPrice       Float?
  quantity        Float
  leverage        Int      @default(1)
  
  // PNL
  pnl             Float?
  pnlPercent      Float?
  fees            Float    @default(0)
  
  // Timing
  entryTime       DateTime
  exitTime        DateTime?
  holdDuration    Int?     // In seconds
  
  // AI decision reference
  decisionId      String?
  aiConfidence    Float?
  aiReasoning     String?
  
  // Status
  status          TradeStatus @default(OPEN)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  profile WalletProfile @relation(fields: [walletAddress], references: [walletAddress], onDelete: Cascade)
  
  @@index([walletAddress])
  @@index([symbol])
  @@index([entryTime])
  @@index([status])
}

// Referral system (for future)
model Referral {
  id              String   @id @default(cuid())
  referrerAddress String
  referredAddress String   @unique
  
  // Referral code used
  code            String
  
  // Rewards
  referrerReward  Float    @default(0)
  referredReward  Float    @default(0)
  
  // Status
  status          ReferralStatus @default(PENDING)
  
  createdAt       DateTime @default(now())
  activatedAt     DateTime?
  
  referrer WalletProfile @relation("Referrer", fields: [referrerAddress], references: [walletAddress], onDelete: Cascade)
  referred WalletProfile @relation("Referred", fields: [referredAddress], references: [walletAddress], onDelete: Cascade)
  
  @@index([referrerAddress])
  @@index([code])
}

enum ReferralStatus {
  PENDING
  ACTIVE
  EXPIRED
}

// ============ Backtest History ============

model BacktestResult {
  id              String   @id @default(cuid())
  walletAddress   String?
  
  // Configuration
  symbol          String
  strategy        String
  strategyParams  Json?
  timeframe       String
  startTime       DateTime
  endTime         DateTime
  initialCapital  Float
  positionSizePct Float
  maxLeverage     Int
  stopLossPct     Float
  takeProfitPct   Float
  tradingFee      Float
  slippage        Float
  enableTrailingStop Boolean @default(false)
  trailingStopPct Float?
  
  // Core Metrics
  totalReturn     Float
  totalReturnPct  Float
  annualizedReturn Float
  maxDrawdown     Float
  maxDrawdownPct  Float
  sharpeRatio     Float
  sortinoRatio    Float
  calmarRatio     Float
  
  // Trade Statistics
  totalTrades     Int
  winningTrades   Int
  losingTrades    Int
  winRate         Float
  profitFactor    Float
  avgWin          Float
  avgLoss         Float
  expectancy      Float
  maxConsecutiveWins Int
  maxConsecutiveLosses Int
  
  // Advanced Quant Metrics
  kellyFraction   Float?
  optimalPositionSize Float?
  valueAtRisk95   Float?
  omegaRatio      Float?
  skewness        Float?
  kurtosis        Float?
  avgHoldingPeriod Float?
  riskRewardRatio Float?
  buyAndHoldReturn Float?
  alphaVsBuyHold  Float?
  
  // Data
  trades          Json     // Array of BacktestTrade
  equityCurve     Json     // Array of EquityPoint
  monthlyReturns  Json?    // Array of monthly returns
  
  // Metadata
  executionTimeMs Int?
  candlesCount    Int?
  notes           String?
  tags            String[]
  
  createdAt       DateTime @default(now())
  
  @@index([walletAddress])
  @@index([symbol])
  @@index([strategy])
  @@index([createdAt])
}

// ============ Wallet Trades (Direct Trading) ============

model WalletTrade {
  id              String   @id @default(cuid())
  walletAddress   String
  symbol          String
  side            TradeSide
  entryPrice      Float
  exitPrice       Float?
  quantity        Float
  leverage        Int      @default(1)
  stopLoss        Float?
  takeProfit      Float?
  entryFee        Float    @default(0)
  exitFee         Float    @default(0)
  pnl             Float?
  pnlWithFees     Float?
  confidence      Int?
  reasoning       String?
  status          TradeStatus @default(OPEN)
  entryTime       DateTime @default(now())
  exitTime        DateTime?
  metadata        Json?    // Additional data like order IDs, etc.
  
  profile WalletProfile? @relation(fields: [walletAddress], references: [walletAddress], onDelete: Cascade)
  
  @@index([walletAddress])
  @@index([symbol])
  @@index([status])
  @@index([entryTime])
}

// ============ User Bots (Multi-bot per wallet) ============

model UserBot {
  id              String        @id @default(cuid())
  walletAddress   String
  name            String
  description     String?
  symbol          String        // Primary trading pair
  timeframe       String        @default("1h")
  status          UserBotStatus @default(DRAFT)
  
  // Strategy configuration
  strategyType    StrategyType  @default(TEMPLATE)
  templateId      String?       // If using a template
  strategyConfig  Json          // Full strategy configuration
  
  // Risk management
  riskConfig      Json          // Position size, SL, TP, leverage, etc.
  
  // Performance tracking
  totalTrades     Int           @default(0)
  winningTrades   Int           @default(0)
  totalPnl        Float         @default(0)
  totalPnlPct     Float         @default(0)
  maxDrawdown     Float         @default(0)
  lastTradeAt     DateTime?
  
  // Remix tracking
  remixedFromId   String?       // If remixed from library
  remixedFrom     LibraryItem?  @relation("RemixedFrom", fields: [remixedFromId], references: [id])
  
  // Timestamps
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  startedAt       DateTime?
  stoppedAt       DateTime?
  
  // Relations
  profile         WalletProfile? @relation(fields: [walletAddress], references: [walletAddress], onDelete: Cascade)
  trades          UserBotTrade[]
  publishedItem   LibraryItem?  @relation("PublishedBot")
  
  @@index([walletAddress])
  @@index([status])
  @@index([symbol])
  @@index([createdAt])
}

enum UserBotStatus {
  DRAFT       // Not yet configured
  READY       // Configured, not running
  BACKTESTING // Currently backtesting
  RUNNING     // Live trading
  PAUSED      // Temporarily paused
  STOPPED     // Manually stopped
  ERROR       // Error state
}

enum StrategyType {
  TEMPLATE    // Based on a template
  CUSTOM      // Custom no-code builder
  AI_GENERATED // Generated by AI
  CODE        // Custom code (future)
}

// Trades executed by user bots
model UserBotTrade {
  id              String      @id @default(cuid())
  userBotId       String
  symbol          String
  side            TradeSide
  entryPrice      Float
  exitPrice       Float?
  quantity        Float
  leverage        Int         @default(1)
  stopLoss        Float?
  takeProfit      Float?
  entryFee        Float       @default(0)
  exitFee         Float       @default(0)
  pnl             Float?
  pnlPct          Float?
  status          TradeStatus @default(OPEN)
  entryTime       DateTime    @default(now())
  exitTime        DateTime?
  reasoning       String?
  
  // On-chain verification
  entryTxHash     String?     // Hyperliquid transaction hash
  exitTxHash      String?
  
  userBot         UserBot     @relation(fields: [userBotId], references: [id], onDelete: Cascade)
  
  @@index([userBotId])
  @@index([status])
  @@index([entryTime])
}

// ============ Community Library ============

model LibraryItem {
  id              String          @id @default(cuid())
  authorWallet    String
  type            LibraryItemType
  name            String
  description     String
  
  // Content
  config          Json            // Bot config, strategy, or backtest result
  tags            String[]
  symbol          String?         // Primary symbol if applicable
  
  // Performance (verified on-chain when possible)
  performance     Json?           // totalReturn, winRate, sharpe, etc.
  isVerified      Boolean         @default(false) // On-chain verified
  verifiedAt      DateTime?
  verificationTxs String[]        // Transaction hashes for verification
  
  // Community stats
  views           Int             @default(0)
  likes           Int             @default(0)
  remixes         Int             @default(0)
  
  // Rating system
  totalRatings    Int             @default(0)
  avgRating       Float           @default(0)
  
  // Privacy
  isPublic        Boolean         @default(true)
  isFeatured      Boolean         @default(false)
  
  // Timestamps
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  
  // Relations
  author          WalletProfile?  @relation(fields: [authorWallet], references: [walletAddress], onDelete: Cascade)
  ratings         LibraryRating[]
  comments        LibraryComment[]
  remixedBots     UserBot[]       @relation("RemixedFrom")
  sourceBot       UserBot?        @relation("PublishedBot", fields: [sourceBotId], references: [id])
  sourceBotId     String?         @unique
  
  @@index([authorWallet])
  @@index([type])
  @@index([isPublic])
  @@index([isFeatured])
  @@index([createdAt])
  @@index([likes])
  @@index([remixes])
}

enum LibraryItemType {
  BOT           // Complete bot configuration
  STRATEGY      // Strategy only (entry/exit conditions)
  TEMPLATE      // Official or community template
  BACKTEST      // Shared backtest results
  INDICATOR     // Custom indicator (future)
}

// Ratings for library items
model LibraryRating {
  id              String      @id @default(cuid())
  libraryItemId   String
  walletAddress   String
  rating          Int         // 1-5 stars
  review          String?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  libraryItem     LibraryItem @relation(fields: [libraryItemId], references: [id], onDelete: Cascade)
  
  @@unique([libraryItemId, walletAddress])
  @@index([libraryItemId])
  @@index([walletAddress])
}

// Comments on library items
model LibraryComment {
  id              String      @id @default(cuid())
  libraryItemId   String
  walletAddress   String
  content         String
  parentId        String?     // For replies
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  libraryItem     LibraryItem @relation(fields: [libraryItemId], references: [id], onDelete: Cascade)
  
  @@index([libraryItemId])
  @@index([walletAddress])
  @@index([parentId])
}

// ============ Bot Templates (Official) ============

model BotTemplate {
  id              String      @id @default(cuid())
  name            String
  description     String
  category        TemplateCategory
  difficulty      TemplateDifficulty
  
  // Configuration
  config          Json        // Default strategy + risk config
  defaultSymbol   String      @default("BTC")
  defaultTimeframe String     @default("1h")
  
  // Metadata
  expectedReturn  String?     // e.g. "5-15% monthly"
  riskLevel       String?     // e.g. "Medium"
  tradingStyle    String?     // e.g. "Swing Trading"
  
  // Stats
  usageCount      Int         @default(0)
  avgPerformance  Float?      // Average performance of bots using this
  
  // Display
  iconName        String?     // Lucide icon name
  color           String?     // Theme color
  isActive        Boolean     @default(true)
  sortOrder       Int         @default(0)
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  @@index([category])
  @@index([isActive])
  @@index([sortOrder])
}

enum TemplateCategory {
  SCALPING      // Quick trades, small profits
  SWING         // Medium-term positions
  TREND         // Trend following
  MEAN_REVERSION // Buy low, sell high
  MOMENTUM      // Follow momentum
  BREAKOUT      // Trade breakouts
  GRID          // Grid trading
  DCA           // Dollar cost averaging
}

enum TemplateDifficulty {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}
